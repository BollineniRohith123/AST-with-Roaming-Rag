// Copyright 2013 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0

#include <algorithm>
#include <cmath>
#include <filesystem>
#include <map>
#include <memory>
#include <numeric>
#include <string>
#include <tuple>
#include <utility>
#include <vector>
#include <sys/types.h>
#include <sys/stat.h>

#include <vips/vips8>
#include <napi.h>

#include "common.h"
#include "operations.h"
#include "pipeline.h"

class PipelineWorker : public Napi::AsyncWorker {
 public:
  PipelineWorker(Napi::Function callback, PipelineBaton *baton,
    Napi::Function debuglog, Napi::Function queueListener) :
    Napi::AsyncWorker(callback),
    baton(baton),
    debuglog(Napi::Persistent(debuglog)),
    queueListener(Napi::Persistent(queueListener)) {}
  ~PipelineWorker() {}

  // libuv worker
  void Execute() {
    // Decrement queued task counter
    sharp::counterQueue--;
    // Increment processing task counter
    sharp::counterProcess++;

    try {
      // Open input
      vips::VImage image;
      sharp::ImageType inputImageType;
      if (baton->join.empty()) {
        std::tie(image, inputImageType) = sharp::OpenInput(baton->input);
      } else {
        std::vector<VImage> images;
        bool hasAlpha = false;
        for (auto &join : baton->join) {
          std::tie(image, inputImageType) = sharp::OpenInput(join);
          image = sharp::EnsureColourspace(image, baton->colourspacePipeline);
          images.push_back(image);
          hasAlpha |= image.has_alpha();
        }
        if (hasAlpha) {
          for (auto &image : images) {
            if (!image.has_alpha()) {
              image = sharp::EnsureAlpha(image, 1);
            }
          }
        } else {
          baton->input->joinBackground.pop_back();
        }
        inputImageType = sharp::ImageType::PNG;
        image = VImage::arrayjoin(images, VImage::option()
          ->set("across", baton->input->joinAcross)
          ->set("shim", baton->input->joinShim)
          ->set("background", baton->input->joinBackground)
          ->set("halign", baton->input->joinHalign)
          ->set("valign", baton->input->joinValign));
        if (baton->input->joinAnimated) {
          image = image.copy();
          image.set(VIPS_META_N_PAGES, static_cast<int>(images.size()));
          image.set(VIPS_META_PAGE_HEIGHT, static_cast<int>(image.height() / images.size()));
        }
      }
      VipsAccess access = baton->input->access;
      image = sharp::EnsureColourspace(image, baton->colourspacePipeline);

      int nPages = baton->input->pages;
      if (nPages == -1) {
        // Resolve the number of pages if we need to render until the end of the document
        nPages = image.get_typeof(VIPS_META_N_PAGES) != 0
          ? image.get_int(VIPS_META_N_PAGES) - baton->input->page
          : 1;
      }

      // Get pre-resize page height
      int pageHeight = sharp::GetPageHeight(image);

      // Calculate angle of rotation
      VipsAngle rotation = VIPS_ANGLE_D0;
      VipsAngle autoRotation = VIPS_ANGLE_D0;
      bool autoFlip = false;
      bool autoFlop = false;

      if (baton->input->autoOrient) {
        // Rotate and flip image according to Exif orientation
        std::tie(autoRotation, autoFlip, autoFlop) = CalculateExifRotationAndFlip(sharp::ExifOrientation(image));
        image = sharp::RemoveExifOrientation(image);
      }

      rotation = CalculateAngleRotation(baton->angle);

      // Rotate pre-extract
      bool const shouldRotateBefore = baton->rotateBeforePreExtract &&
        (rotation != VIPS_ANGLE_D0 || autoRotation != VIPS_ANGLE_D0 ||
          autoFlip || baton->flip || autoFlop || baton->flop ||
          baton->rotationAngle != 0.0);

      if (shouldRotateBefore) {
        image = sharp::StaySequential(image,
          rotation != VIPS_ANGLE_D0 ||
          autoRotation != VIPS_ANGLE_D0 ||
          autoFlip ||
          baton->flip ||
          baton->rotationAngle != 0.0);

        if (autoRotation != VIPS_ANGLE_D0) {
          if (autoRotation != VIPS_ANGLE_D180) {
            MultiPageUnsupported(nPages, "Rotate");
          }
          image = image.rot(autoRotation);
          autoRotation = VIPS_ANGLE_D0;
        }
        if (autoFlip != baton->flip) {
          image = image.flip(VIPS_DIRECTION_VERTICAL);
          autoFlip = false;
          baton->flip = false;
        }
        if (autoFlop != baton->flop) {
          image = image.flip(VIPS_DIRECTION_HORIZONTAL);
          autoFlop = false;
          baton->flop = false;
        }
        if (rotation != VIPS_ANGLE_D0) {
          if (rotation != VIPS_ANGLE_D180) {
            MultiPageUnsupported(nPages, "Rotate");
          }
          image = image.rot(rotation);
          rotation = VIPS_ANGLE_D0;
        }
        if (baton->rotationAngle != 0.0) {
          MultiPageUnsupported(nPages, "Rotate");
          std::vector<double> background;
          std::tie(image, background) = sharp::ApplyAlpha(image, baton->rotationBackground, false);
          image = image.rotate(baton->rotationAngle, VImage::option()->set("background", background)).copy_memory();
        }
      }

      // Trim
      if (baton->trimThreshold >= 0.0) {
        MultiPageUnsupported(nPages, "Trim");
        image = sharp::StaySequential(image);
        image = sharp::Trim(image, baton->trimBackground, baton->trimThreshold, baton->trimLineArt);
        baton->trimOffsetLeft = image.xoffset();
        baton->trimOffsetTop = image.yoffset();
      }

      // Pre extraction
      if (baton->topOffsetPre != -1) {
        image = nPages > 1
          ? sharp::CropMultiPage(image,
              baton->leftOffsetPre, baton->topOffsetPre, baton->widthPre, baton->heightPre, nPages, &pageHeight)
          : image.extract_area(baton->leftOffsetPre, baton->topOffsetPre, baton->widthPre, baton->heightPre);
      }

      // Get pre-resize image width and height
      int inputWidth = image.width();
      int inputHeight = image.height();

      // Is there just one page? Shrink to inputHeight instead
      if (nPages == 1) {
        pageHeight = inputHeight;
      }

      // Scaling calculations
      double hshrink;
      double vshrink;
      int targetResizeWidth = baton->width;
      int targetResizeHeight = baton->height;

      // When auto-rotating by 90 or 270 degrees, swap the target width and
      // height to ensure the behavior aligns with how it would have been if
      // the rotation had taken place *before* resizing.
      if (!baton->rotateBeforePreExtract &&
        (autoRotation == VIPS_ANGLE_D90 || autoRotation == VIPS_ANGLE_D270)) {
        std::swap(targetResizeWidth, targetResizeHeight);
      }

      // Shrink to pageHeight, so we work for multi-page images
      std::tie(hshrink, vshrink) = sharp::ResolveShrink(
        inputWidth, pageHeight, targetResizeWidth, targetResizeHeight,
        baton->canvas, baton->withoutEnlargement, baton->withoutReduction);

      // The jpeg preload shrink.
      int jpegShrinkOnLoad = 1;

      // WebP, PDF, SVG scale
      double scale = 1.0;

      // Try to reload input using shrink-on-load for JPEG, WebP, SVG and PDF, when:
      //  - the width or height parameters are specified;
      //  - gamma correction doesn't need to be applied;
      //  - trimming or pre-resize extract isn't required;
      //  - input colourspace is not specified;
      bool const shouldPreShrink = (targetResizeWidth > 0 || targetResizeHeight > 0) &&
        baton->gamma == 0 && baton->topOffsetPre == -1 && baton->trimThreshold < 0.0 &&
        baton->colourspacePipeline == VIPS_INTERPRETATION_LAST && !shouldRotateBefore;

      if (shouldPreShrink) {
        // The common part of the shrink: the bit by which both axes must be shrunk
        double shrink = std::min(hshrink, vshrink);

        if (inputImageType == sharp::ImageType::JPEG) {
          // Leave at least a factor of two for the final resize step, when fastShrinkOnLoad: false
          // for more consistent results and to avoid extra sharpness to the image
          int factor = baton->fastShrinkOnLoad ? 1 : 2;
          if (shrink >= 8 * factor) {
            jpegShrinkOnLoad = 8;
          } else if (shrink >= 4 * factor) {
            jpegShrinkOnLoad = 4;
          } else if (shrink >= 2 * factor) {
            jpegShrinkOnLoad = 2;
          }
          // Lower shrink-on-load for known libjpeg rounding errors
          if (jpegShrinkOnLoad > 1 && static_cast<int>(shrink) == jpegShrinkOnLoad) {
            jpegShrinkOnLoad /= 2;
          }
        } else if (inputImageType == sharp::ImageType::WEBP && baton->fastShrinkOnLoad && shrink > 1.0) {
          // Avoid upscaling via webp
          scale = 1.0 / shrink;
        } else if (inputImageType == sharp::ImageType::SVG ||
                   inputImageType == sharp::ImageType::PDF) {
          scale = 1.0 / shrink;
        }
      }

      // Reload input using shrink-on-load, it'll be an integer shrink
      // factor for jpegload*, a double scale factor for webpload*,
      // pdfload* and svgload*
      if (jpegShrinkOnLoad > 1) {
        vips::VOption *option = VImage::option()
          ->set("access", access)
          ->set("shrink", jpegShrinkOnLoad)
          ->set("unlimited", baton->input->unlimited)
          ->set("fail_on", baton->input->failOn);
        if (baton->input->buffer != nullptr) {
          // Reload JPEG buffer
          VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);
          image = VImage::jpegload_buffer(blob, option);
          vips_area_unref(reinterpret_cast<VipsArea*>(blob));
        } else {
          // Reload JPEG file
          image = VImage::jpegload(const_cast<char*>(baton->input->file.data()), option);
        }
      } else if (scale != 1.0) {
        vips::VOption *option = VImage::option()
          ->set("access", access)
          ->set("scale", scale)
          ->set("fail_on", baton->input->failOn);
        if (inputImageType == sharp::ImageType::WEBP) {
          option->set("n", baton->input->pages);
          option->set("page", baton->input->page);

          if (baton->input->buffer != nullptr) {
            // Reload WebP buffer
            VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);
            image = VImage::webpload_buffer(blob, option);
            vips_area_unref(reinterpret_cast<VipsArea*>(blob));
          } else {
            // Reload WebP file
            image = VImage::webpload(const_cast<char*>(baton->input->file.data()), option);
          }
        } else if (inputImageType == sharp::ImageType::SVG) {
          option->set("unlimited", baton->input->unlimited);
          option->set("dpi", baton->input->density);

          if (baton->input->buffer != nullptr) {
            // Reload SVG buffer
            VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);
            image = VImage::svgload_buffer(blob, option);
            vips_area_unref(reinterpret_cast<VipsArea*>(blob));
          } else {
            // Reload SVG file
            image = VImage::svgload(const_cast<char*>(baton->input->file.data()), option);
          }
          sharp::SetDensity(image, baton->input->density);
          if (image.width() > 32767 || image.height() > 32767) {
            throw vips::VError("Input SVG image will exceed 32767x32767 pixel limit when scaled");
          }
        } else if (inputImageType == sharp::ImageType::PDF) {
          option->set("n", baton->input->pages);
          option->set("page", baton->input->page);
          option->set("dpi", baton->input->density);

          if (baton->input->buffer != nullptr) {
            // Reload PDF buffer
            VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);
            image = VImage::pdfload_buffer(blob, option);
            vips_area_unref(reinterpret_cast<VipsArea*>(blob));
          } else {
            // Reload PDF file
            image = VImage::pdfload(const_cast<char*>(baton->input->file.data()), option);
          }

          sharp::SetDensity(image, baton->input->density);
        }
      } else {
        if (inputImageType == sharp::ImageType::SVG && (image.width() > 32767 || image.height() > 32767)) {
          throw vips::VError("Input SVG image exceeds 32767x32767 pixel limit");
        }
      }

      // Any pre-shrinking may already have been done
      inputWidth = image.width();
      inputHeight = image.height();

      // After pre-shrink, but before the main shrink stage
      // Reuse the initial pageHeight if we didn't pre-shrink
      if (shouldPreShrink) {
        pageHeight = sharp::GetPageHeight(image);
      }

      // Shrink to pageHeight, so we work for multi-page images
      std::tie(hshrink, vshrink) = sharp::ResolveShrink(
        inputWidth, pageHeight, targetResizeWidth, targetResizeHeight,
        baton->canvas, baton->withoutEnlargement, baton->withoutReduction);

      int targetHeight = static_cast<int>(std::rint(static_cast<double>(pageHeight) / vshrink));
      int targetPageHeight = targetHeight;

      // In toilet-roll mode, we must adjust vshrink so that we exactly hit
      // pageHeight or we'll have pixels straddling pixel boundaries
      if (inputHeight > pageHeight) {
        targetHeight *= nPages;
        vshrink = static_cast<double>(inputHeight) / targetHeight;
      }

      // Ensure we're using a device-independent colour space
      std::pair<char*, size_t> inputProfile(nullptr, 0);
      if ((baton->keepMetadata & VIPS_FOREIGN_KEEP_ICC) && baton->withIccProfile.empty()) {
        // Cache input profile for use with output
        inputProfile = sharp::GetProfile(image);
        baton->input->ignoreIcc = true;
      }
      char const *processingProfile = image.interpretation() == VIPS_INTERPRETATION_RGB16 ? "p3" : "srgb";
      if (
        sharp::HasProfile(image) &&
        image.interpretation() != VIPS_INTERPRETATION_LABS &&
        image.interpretation() != VIPS_INTERPRETATION_GREY16 &&
        baton->colourspacePipeline != VIPS_INTERPRETATION_CMYK &&
        !baton->input->ignoreIcc
      ) {
        // Convert to sRGB/P3 using embedded profile
        try {
          image = image.icc_transform(processingProfile, VImage::option()
            ->set("embedded", true)
            ->set("depth", sharp::Is16Bit(image.interpretation()) ? 16 : 8)
            ->set("intent", VIPS_INTENT_PERCEPTUAL));
        } catch(...) {
          sharp::VipsWarningCallback(nullptr, G_LOG_LEVEL_WARNING, "Invalid embedded profile", nullptr);
        }
      } else if (
        image.interpretation() == VIPS_INTERPRETATION_CMYK &&
        baton->colourspacePipeline != VIPS_INTERPRETATION_CMYK
      ) {
        image = image.icc_transform(processingProfile, VImage::option()
          ->set("input_profile", "cmyk")
          ->set("intent", VIPS_INTENT_PERCEPTUAL));
      }

      // Flatten image to remove alpha channel
      if (baton->flatten && image.has_alpha()) {
        image = sharp::Flatten(image, baton->flattenBackground);
      }

      // Gamma encoding (darken)
      if (baton->gamma >= 1 && baton->gamma <= 3) {
        image = sharp::Gamma(image, 1.0 / baton->gamma);
      }

      // Convert to greyscale (linear, therefore after gamma encoding, if any)
      if (baton->greyscale) {
        image = image.colourspace(VIPS_INTERPRETATION_B_W);
      }

      bool const shouldResize = hshrink != 1.0 || vshrink != 1.0;
      bool const shouldBlur = baton->blurSigma != 0.0;
      bool const shouldConv = baton->convKernelWidth * baton->convKernelHeight > 0;
      bool const shouldSharpen = baton->sharpenSigma != 0.0;
      bool const shouldComposite = !baton->composite.empty();

      if (shouldComposite && !image.has_alpha()) {
        image = sharp::EnsureAlpha(image, 1);
      }

      VipsBandFormat premultiplyFormat = image.format();
      bool const shouldPremultiplyAlpha = image.has_alpha() &&
        (shouldResize || shouldBlur || shouldConv || shouldSharpen);

      if (shouldPremultiplyAlpha) {
        image = image.premultiply().cast(premultiplyFormat);
      }

      // Resize
      if (shouldResize) {
        image = image.resize(1.0 / hshrink, VImage::option()
          ->set("vscale", 1.0 / vshrink)
          ->set("kernel", baton->kernel));
      }

      image = sharp::StaySequential(image,
        autoRotation != VIPS_ANGLE_D0 ||
        baton->flip ||
        autoFlip ||
        rotation != VIPS_ANGLE_D0);
      // Auto-rotate post-extract
      if (autoRotation != VIPS_ANGLE_D0) {
        if (autoRotation != VIPS_ANGLE_D180) {
          MultiPageUnsupported(nPages, "Rotate");
        }
        image = image.rot(autoRotation);
      }
      // Mirror vertically (up-down) about the x-axis
      if (baton->flip != autoFlip) {
        image = image.flip(VIPS_DIRECTION_VERTICAL);
      }
      // Mirror horizontally (left-right) about the y-axis
      if (baton->flop != autoFlop) {
        image = image.flip(VIPS_DIRECTION_HORIZONTAL);
      }
      // Rotate post-extract 90-angle
      if (rotation != VIPS_ANGLE_D0) {
        if (rotation != VIPS_ANGLE_D180) {
          MultiPageUnsupported(nPages, "Rotate");
        }
        image = image.rot(rotation);
      }

      // Join additional color channels to the image
      if (!baton->joinChannelIn.empty()) {
        VImage joinImage;
        sharp::ImageType joinImageType = sharp::ImageType::UNKNOWN;

        for (unsigned int i = 0; i < baton->joinChannelIn.size(); i++) {
          baton->joinChannelIn[i]->access = access;
          std::tie(joinImage, joinImageType) = sharp::OpenInput(baton->joinChannelIn[i]);
          joinImage = sharp::EnsureColourspace(joinImage, baton->colourspacePipeline);
          image = image.bandjoin(joinImage);
        }
        image = image.copy(VImage::option()->set("interpretation", baton->colourspace));
        image = sharp::RemoveGifPalette(image);
      }

      inputWidth = image.width();
      inputHeight = nPages > 1 ? targetPageHeight : image.height();

      // Resolve dimensions
      if (baton->width <= 0) {
        baton->width = inputWidth;
      }
      if (baton->height <= 0) {
        baton->height = inputHeight;
      }

      // Crop/embed
      if (inputWidth != baton->width || inputHeight != baton->height) {
        if (baton->canvas == sharp::Canvas::EMBED) {
          std::vector<double> background;
          std::tie(image, background) = sharp::ApplyAlpha(image, baton->resizeBackground, shouldPremultiplyAlpha);

          // Embed
          int left;
          int top;
          std::tie(left, top) = sharp::CalculateEmbedPosition(
            inputWidth, inputHeight, baton->width, baton->height, baton->position);
          int width = std::max(inputWidth, baton->width);
          int height = std::max(inputHeight, baton->height);

          image = nPages > 1
            ? sharp::EmbedMultiPage(image,
                left, top, width, height, VIPS_EXTEND_BACKGROUND, background, nPages, &targetPageHeight)
            : image.embed(left, top, width, height, VImage::option()
              ->set("extend", VIPS_EXTEND_BACKGROUND)
              ->set("background", background));
        } else if (baton->canvas == sharp::Canvas::CROP) {
          if (baton->width > inputWidth) {
            baton->width = inputWidth;
          }
          if (baton->height > inputHeight) {
            baton->height = inputHeight;
          }

          // Crop
          if (baton->position < 9) {
            // Gravity-based crop
            int left;
            int top;

            std::tie(left, top) = sharp::CalculateCrop(
              inputWidth, inputHeight, baton->width, baton->height, baton->position);
            int width = std::min(inputWidth, baton->width);
            int height = std::min(inputHeight, baton->height);

            image = nPages > 1
              ? sharp::CropMultiPage(image,
                  left, top, width, height, nPages, &targetPageHeight)
              : image.extract_area(left, top, width, height);
          } else {
            int attention_x;
            int attention_y;

            // Attention-based or Entropy-based crop
            MultiPageUnsupported(nPages, "Resize strategy");
            image = sharp::StaySequential(image);
            image = image.smartcrop(baton->width, baton->height, VImage::option()
              ->set("interesting", baton->position == 16 ? VIPS_INTERESTING_ENTROPY : VIPS_INTERESTING_ATTENTION)
              ->set("premultiplied", shouldPremultiplyAlpha)
              ->set("attention_x", &attention_x)
              ->set("attention_y", &attention_y));
            baton->hasCropOffset = true;
            baton->cropOffsetLeft = static_cast<int>(image.xoffset());
            baton->cropOffsetTop = static_cast<int>(image.yoffset());
            baton->hasAttentionCenter = true;
            baton->attentionX = static_cast<int>(attention_x * jpegShrinkOnLoad / scale);
            baton->attentionY = static_cast<int>(attention_y * jpegShrinkOnLoad / scale);
          }
        }
      }

      // Rotate post-extract non-90 angle
      if (!baton->rotateBeforePreExtract && baton->rotationAngle != 0.0) {
        MultiPageUnsupported(nPages, "Rotate");
        image = sharp::StaySequential(image);
        std::vector<double> background;
        std::tie(image, background) = sharp::ApplyAlpha(image, baton->rotationBackground, shouldPremultiplyAlpha);
        image = image.rotate(baton->rotationAngle, VImage::option()->set("background", background));
      }

      // Post extraction
      if (baton->topOffsetPost != -1) {
        if (nPages > 1) {
          image = sharp::CropMultiPage(image,
            baton->leftOffsetPost, baton->topOffsetPost, baton->widthPost, baton->heightPost,
            nPages, &targetPageHeight);

          // heightPost is used in the info object, so update to reflect the number of pages
          baton->heightPost *= nPages;
        } else {
          image = image.extract_area(
            baton->leftOffsetPost, baton->topOffsetPost, baton->widthPost, baton->heightPost);
        }
      }

      // Affine transform
      if (!baton->affineMatrix.empty()) {
        MultiPageUnsupported(nPages, "Affine");
        image = sharp::StaySequential(image);
        std::vector<double> background;
        std::tie(image, background) = sharp::ApplyAlpha(image, baton->affineBackground, shouldPremultiplyAlpha);
        vips::VInterpolate interp = vips::VInterpolate::new_from_name(
          const_cast<char*>(baton->affineInterpolator.data()));
        image = image.affine(baton->affineMatrix, VImage::option()->set("background", background)
          ->set("idx", baton->affineIdx)
          ->set("idy", baton->affineIdy)
          ->set("odx", baton->affineOdx)
          ->set("ody", baton->affineOdy)
          ->set("interpolate", interp));
      }

      // Extend edges
      if (baton->extendTop > 0 || baton->extendBottom > 0 || baton->extendLeft > 0 || baton->extendRight > 0) {
        // Embed
        baton->width = image.width() + baton->extendLeft + baton->extendRight;
        baton->height = (nPages > 1 ? targetPageHeight : image.height()) + baton->extendTop + baton->extendBottom;

        if (baton->extendWith == VIPS_EXTEND_BACKGROUND) {
          std::vector<double> background;
          std::tie(image, background) = sharp::ApplyAlpha(image, baton->extendBackground, shouldPremultiplyAlpha);

          image = sharp::StaySequential(image, nPages > 1);
          image = nPages > 1
            ? sharp::EmbedMultiPage(image,
                baton->extendLeft, baton->extendTop, baton->width, baton->height,
                baton->extendWith, background, nPages, &targetPageHeight)
            : image.embed(baton->extendLeft, baton->extendTop, baton->width, baton->height,
                VImage::option()->set("extend", baton->extendWith)->set("background", background));
        } else {
          std::vector<double> ignoredBackground(1);
          image = sharp::StaySequential(image);
          image = nPages > 1
            ? sharp::EmbedMultiPage(image,
                baton->extendLeft, baton->extendTop, baton->width, baton->height,
                baton->extendWith, ignoredBackground, nPages, &targetPageHeight)
            : image.embed(baton->extendLeft, baton->extendTop, baton->width, baton->height,
                VImage::option()->set("extend", baton->extendWith));
        }
      }
      // Median - must happen before blurring, due to the utility of blurring after thresholding
      if (baton->medianSize > 0) {
        image = image.median(baton->medianSize);
      }

      // Threshold - must happen before blurring, due to the utility of blurring after thresholding
      // Threshold - must happen before unflatten to enable non-white unflattening
      if (baton->threshold != 0) {
        image = sharp::Threshold(image, baton->threshold, baton->thresholdGrayscale);
      }

      // Dilate - must happen before blurring, due to the utility of dilating after thresholding
      if (baton->dilateWidth != 0) {
        image = sharp::Dilate(image, baton->dilateWidth);
      }

      // Erode - must happen before blurring, due to the utility of eroding after thresholding
      if (baton->erodeWidth != 0) {
        image = sharp::Erode(image, baton->erodeWidth);
      }

      // Blur
      if (shouldBlur) {
        image = sharp::Blur(image, baton->blurSigma, baton->precision, baton->minAmpl);
      }

      // Unflatten the image
      if (baton->unflatten) {
        image = sharp::Unflatten(image);
      }

      // Convolve
      if (shouldConv) {
        image = sharp::Convolve(image,
          baton->convKernelWidth, baton->convKernelHeight,
          baton->convKernelScale, baton->convKernelOffset,
          baton->convKernel);
      }

      // Recomb
      if (!baton->recombMatrix.empty()) {
        image = sharp::Recomb(image, baton->recombMatrix);
      }

      // Modulate
      if (baton->brightness != 1.0 || baton->saturation != 1.0 || baton->hue != 0.0 || baton->lightness != 0.0) {
        image = sharp::Modulate(image, baton->brightness, baton->saturation, baton->hue, baton->lightness);
      }

      // Sharpen
      if (shouldSharpen) {
        image = sharp::Sharpen(image, baton->sharpenSigma, baton->sharpenM1, baton->sharpenM2,
          baton->sharpenX1, baton->sharpenY2, baton->sharpenY3);
      }

      // Reverse premultiplication after all transformations
      if (shouldPremultiplyAlpha) {
        image = image.unpremultiply().cast(premultiplyFormat);
      }
      baton->premultiplied = shouldPremultiplyAlpha;

      // Composite
      if (shouldComposite) {
        std::vector<VImage> images = { image };
        std::vector<int> modes, xs, ys;
        for (Composite *composite : baton->composite) {
          VImage compositeImage;
          sharp::ImageType compositeImageType = sharp::ImageType::UNKNOWN;
          composite->input->access = access;
          std::tie(compositeImage, compositeImageType) = sharp::OpenInput(composite->input);
          compositeImage = sharp::EnsureColourspace(compositeImage, baton->colourspacePipeline);

          if (composite->input->autoOrient) {
            // Respect EXIF Orientation
            VipsAngle compositeAutoRotation = VIPS_ANGLE_D0;
            bool compositeAutoFlip = false;
            bool compositeAutoFlop = false;
            std::tie(compositeAutoRotation, compositeAutoFlip, compositeAutoFlop) =
              CalculateExifRotationAndFlip(sharp::ExifOrientation(compositeImage));

            compositeImage = sharp::RemoveExifOrientation(compositeImage);
            compositeImage = sharp::StaySequential(compositeImage,
              compositeAutoRotation != VIPS_ANGLE_D0 || compositeAutoFlip);

            if (compositeAutoRotation != VIPS_ANGLE_D0) {
              compositeImage = compositeImage.rot(compositeAutoRotation);
            }
            if (compositeAutoFlip) {
              compositeImage = compositeImage.flip(VIPS_DIRECTION_VERTICAL);
            }
            if (compositeAutoFlop) {
              compositeImage = compositeImage.flip(VIPS_DIRECTION_HORIZONTAL);
            }
          }

          // Verify within current dimensions
          if (compositeImage.width() > image.width() || compositeImage.height() > image.height()) {
            throw vips::VError("Image to composite must have same dimensions or smaller");
          }
          // Check if overlay is tiled
          if (composite->tile) {
            int across = 0;
            int down = 0;
            // Use gravity in overlay
            if (compositeImage.width() <= image.width()) {
              across = static_cast<int>(ceil(static_cast<double>(image.width()) / compositeImage.width()));
              // Ensure odd number of tiles across when gravity is centre, north or south
              if (composite->gravity == 0 || composite->gravity == 1 || composite->gravity == 3) {
                across |= 1;
              }
            }
            if (compositeImage.height() <= image.height()) {
              down = static_cast<int>(ceil(static_cast<double>(image.height()) / compositeImage.height()));
              // Ensure odd number of tiles down when gravity is centre, east or west
              if (composite->gravity == 0 || composite->gravity == 2 || composite->gravity == 4) {
                down |= 1;
              }
            }
            if (across != 0 || down != 0) {
              int left;
              int top;
              compositeImage = sharp::StaySequential(compositeImage).replicate(across, down);
              if (composite->hasOffset) {
                std::tie(left, top) = sharp::CalculateCrop(
                  compositeImage.width(), compositeImage.height(), image.width(), image.height(),
                  composite->left, composite->top);
              } else {
                std::tie(left, top) = sharp::CalculateCrop(
                  compositeImage.width(), compositeImage.height(), image.width(), image.height(), composite->gravity);
              }
              compositeImage = compositeImage.extract_area(left, top, image.width(), image.height());
            }
            // gravity was used for extract_area, set it back to its default value of 0
            composite->gravity = 0;
          }
          // Ensure image to composite is sRGB with unpremultiplied alpha
          compositeImage = compositeImage.colourspace(VIPS_INTERPRETATION_sRGB);
          compositeImage = sharp::EnsureAlpha(compositeImage, 1);
          if (composite->premultiplied) compositeImage = compositeImage.unpremultiply();
          // Calculate position
          int left;
          int top;
          if (composite->hasOffset) {
            // Composite image at given offsets
            if (composite->tile) {
              std::tie(left, top) = sharp::CalculateCrop(image.width(), image.height(),
                compositeImage.width(), compositeImage.height(), composite->left, composite->top);
            } else {
              left = composite->left;
              top = composite->top;
            }
          } else {
            // Composite image with given gravity
            std::tie(left, top) = sharp::CalculateCrop(image.width(), image.height(),
              compositeImage.width(), compositeImage.height(), composite->gravity);
          }
          images.push_back(compositeImage);
          modes.push_back(composite->mode);
          xs.push_back(left);
          ys.push_back(top);
        }
        image = VImage::composite(images, modes, VImage::option()->set("x", xs)->set("y", ys));
        image = sharp::RemoveGifPalette(image);
      }

      // Gamma decoding (brighten)
      if (baton->gammaOut >= 1 && baton->gammaOut <= 3) {
        image = sharp::Gamma(image, baton->gammaOut);
      }

      // Linear adjustment (a * in + b)
      if (!baton->linearA.empty()) {
        image = sharp::Linear(image, baton->linearA, baton->linearB);
      }

      // Apply normalisation - stretch luminance to cover full dynamic range
      if (baton->normalise) {
        image = sharp::StaySequential(image);
        image = sharp::Normalise(image, baton->normaliseLower, baton->normaliseUpper);
      }

      // Apply contrast limiting adaptive histogram equalization (CLAHE)
      if (baton->claheWidth != 0 && baton->claheHeight != 0) {
        image = sharp::StaySequential(image);
        image = sharp::Clahe(image, baton->claheWidth, baton->claheHeight, baton->claheMaxSlope);
      }

      // Apply bitwise boolean operation between images
      if (baton->boolean != nullptr) {
        VImage booleanImage;
        sharp::ImageType booleanImageType = sharp::ImageType::UNKNOWN;
        baton->boolean->access = access;
        std::tie(booleanImage, booleanImageType) = sharp::OpenInput(baton->boolean);
        booleanImage = sharp::EnsureColourspace(booleanImage, baton->colourspacePipeline);
        image = sharp::Boolean(image, booleanImage, baton->booleanOp);
        image = sharp::RemoveGifPalette(image);
      }

      // Apply per-channel Bandbool bitwise operations after all other operations
      if (baton->bandBoolOp >= VIPS_OPERATION_BOOLEAN_AND && baton->bandBoolOp < VIPS_OPERATION_BOOLEAN_LAST) {
        image = sharp::Bandbool(image, baton->bandBoolOp);
      }

      // Tint the image
      if (baton->tint[0] >= 0.0) {
        image = sharp::Tint(image, baton->tint);
      }

      // Remove alpha channel, if any
      if (baton->removeAlpha) {
        image = sharp::RemoveAlpha(image);
      }

      // Ensure alpha channel, if missing
      if (baton->ensureAlpha != -1) {
        image = sharp::EnsureAlpha(image, baton->ensureAlpha);
      }

      // Convert image to sRGB, if not already
      if (sharp::Is16Bit(image.interpretation())) {
        image = image.cast(VIPS_FORMAT_USHORT);
      }
      if (image.interpretation() != baton->colourspace) {
        // Convert colourspace, pass the current known interpretation so libvips doesn't have to guess
        image = image.colourspace(baton->colourspace, VImage::option()->set("source_space", image.interpretation()));
        // Transform colours from embedded profile to output profile
        if ((baton->keepMetadata & VIPS_FOREIGN_KEEP_ICC) && baton->colourspacePipeline != VIPS_INTERPRETATION_CMYK &&
          baton->withIccProfile.empty() && sharp::HasProfile(image)) {
          image = image.icc_transform(processingProfile, VImage::option()
            ->set("embedded", true)
            ->set("depth", sharp::Is16Bit(image.interpretation()) ? 16 : 8)
            ->set("intent", VIPS_INTENT_PERCEPTUAL));
        }
      }

      // Extract channel
      if (baton->extractChannel > -1) {
        if (baton->extractChannel >= image.bands()) {
          if (baton->extractChannel == 3 && image.has_alpha()) {
            baton->extractChannel = image.bands() - 1;
          } else {
            (baton->err)
              .append("Cannot extract channel ").append(std::to_string(baton->extractChannel))
              .append(" from image with channels 0-").append(std::to_string(image.bands() - 1));
            return Error();
          }
        }
        VipsInterpretation colourspace = sharp::Is16Bit(image.interpretation())
          ? VIPS_INTERPRETATION_GREY16
          : VIPS_INTERPRETATION_B_W;
        image = image
          .extract_band(baton->extractChannel)
          .copy(VImage::option()->set("interpretation", colourspace));
      }

      // Apply output ICC profile
      if (!baton->withIccProfile.empty()) {
        try {
          image = image.icc_transform(const_cast<char*>(baton->withIccProfile.data()), VImage::option()
            ->set("input_profile", processingProfile)
            ->set("embedded", true)
            ->set("depth", sharp::Is16Bit(image.interpretation()) ? 16 : 8)
            ->set("intent", VIPS_INTENT_PERCEPTUAL));
        } catch(...) {
          sharp::VipsWarningCallback(nullptr, G_LOG_LEVEL_WARNING, "Invalid profile", nullptr);
        }
      } else if (baton->keepMetadata & VIPS_FOREIGN_KEEP_ICC) {
        image = sharp::SetProfile(image, inputProfile);
      }

      // Negate the colours in the image
      if (baton->negate) {
        image = sharp::Negate(image, baton->negateAlpha);
      }

      // Override EXIF Orientation tag
      if (baton->withMetadataOrientation != -1) {
        image = sharp::SetExifOrientation(image, baton->withMetadataOrientation);
      }
      // Override pixel density
      if (baton->withMetadataDensity > 0) {
        image = sharp::SetDensity(image, baton->withMetadataDensity);
      }
      // EXIF key/value pairs
      if (ba